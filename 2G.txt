import numpy as np
import random

def read_file(path='Chapter 2/rosalind_ba2g.txt'):
    with open(path) as f:
        fs = [i.strip() for i in f.readlines()] 
        k, t, N = map(int, fs[0].split())
        dna_strings = fs[1:]
    return k, t, N, dna_strings

def generate_random_kmers(dna_strings, k, t):
    n = len(dna_strings[0])
    random_kmers = []
    for i in range(t):
        #randomly generated number 0 to n-k
        x = random.randint(0, n-k)
        random_kmers.append(dna_strings[i][x: x+k])
    return random_kmers

def form_profile_matrix(motif_array, k, t): #NOW WITH PSEUDOCOUNTS! pass in an array of motifs 
    a_count_array = np.ones(k)
    c_count_array = np.ones(k)
    g_count_array = np.ones(k)
    t_count_array = np.ones(k)
    #form a_count_array
    for motif in motif_array:
        for i in range(k):
            if motif[i] == 'A':
                a_count_array[i]  += 1
            if motif[i] == 'C':
                c_count_array[i]  += 1
            if motif[i] == 'G':
                g_count_array[i]  += 1
            if motif[i] == 'T':
                t_count_array[i]  += 1
    profile_matrix = np.array([a_count_array/(t+4), c_count_array/(t+4), g_count_array/(t+4), t_count_array/(t+4)]) 
    return profile_matrix

def kmers_in_Text(Text, k):
    kmers_in_Text = []
    n = len(Text)
    for i in range(n-k+1):
        kmers_in_Text.append(Text[i:i+k])
    return kmers_in_Text

def kmer_probability(kmer, k, profile_matrix):
    "Calculate the probability of a kmer given the profile matrix"
    probability = 1
    for i in range(k):
        if kmer[i] == 'A':
            probability = probability*profile_matrix[0][i]
        if kmer[i] == 'C':
            probability = probability*profile_matrix[1][i]
        if kmer[i] == 'G':
            probability = probability*profile_matrix[2][i]
        if kmer[i] == 'T':
            probability = probability*profile_matrix[3][i]
    return probability

def profile_randomly_generated_kmer(Text, profile_matrix, k, t): #if smth goes wrong check this first (newest)
    all_kmers = kmers_in_Text(Text, k)
    p_array = []
    for kmer in all_kmers:
        p_array.append(kmer_probability(kmer, k, profile_matrix))
    my_array = np.array(p_array)
    prob_array = my_array/np.sum(my_array)
    gen_kmer = all_kmers[np.random.choice(len(prob_array), p=prob_array)]
    return gen_kmer

def form_consensus(motif_array, k, t): 
    """Forms consensus string, which is useful in finding the score"""
    profile_matrix = form_profile_matrix(motif_array, k, t)
    transpose_profile_matrix = profile_matrix.transpose() #just makes easier to write for loops below
    consensus = ""
    for i in range(k):
        #find location of max value in transpose_profile_matrix[i]. If location of max value is 0, append A to string etc.
        temp = list(transpose_profile_matrix[i])
        max_value = max(temp) 
        max_index = temp.index(max_value)
        if max_index == 0:
            consensus = consensus + 'A'
        if max_index == 1:
            consensus = consensus + 'C'    
        if max_index == 2:
            consensus = consensus + 'G'
        if max_index == 3:
            consensus = consensus + 'T'
    return consensus #haven't tested this yet!!!

def hamming_distance(string1, string2):
    """Used to calculate score below"""
    stringlength = len(string1)
    count = 0
    for i in range(stringlength):
        if string1[i] != string2[i]:
            count += 1
    return count

def calculate_score(motif_array, k, t):
    "Forms consensus string from above matrix, and then calculates the score of motif_array"
    consensus = form_consensus(motif_array, k, t)
    score = 0 #initalize 
    #sum the Hamming distances over each motif row of motif_array
    for i in range(len(motif_array)):
        score += hamming_distance(motif_array[i], consensus)
    return score


def gibbs_sampler(dna_strings, k, t, N):
    motifs = generate_random_kmers(dna_strings, k, t)
    #print(motifs)
    best_motifs = motifs
    for j in range(N):
        i = random.randint(0, t-1)
        motifs_without_i = motifs[:i] + motifs[i+1:]
        profile_matrix = form_profile_matrix(motifs_without_i, k, t)
        motifs[i] = profile_randomly_generated_kmer(dna_strings[i], profile_matrix, k, t)
        if calculate_score(motifs, k, t) < calculate_score(best_motifs, k, t):
            best_motifs = motifs
    return best_motifs

k, t, N, dna_strings = read_file()
best_from_gibbs = gibbs_sampler(dna_strings, k, t, N) #initialize and do it once so smth to compare
for i in range(19):
    new_gibbs = gibbs_sampler(dna_strings, k, t, N)
    if calculate_score(new_gibbs, k, t) < calculate_score(best_from_gibbs,k,t):
        best_from_gibbs = new_gibbs

output = "\n".join(best_from_gibbs)
print(output)